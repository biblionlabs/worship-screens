import { Palette, ScrollView } from "std-widgets.slint";

export component DragableIcon inherits GridLayout {
    spacing: 2px;

    in property <length> size: 5px;
    in property <brush> color: black;

    Row {
        Rectangle {
            width: size;
            height: size;
            background: color;
            border-radius: size;
        }

        Rectangle {
            width: size;
            height: size;
            background: color;
            border-radius: size;
        }
    }

    Row {
        Rectangle {
            width: size;
            height: size;
            background: color;
            border-radius: size;
        }

        Rectangle {
            width: size;
            height: size;
            background: color;
            border-radius: size;
        }
    }

    Row {
        Rectangle {
            width: size;
            height: size;
            background: color;
            border-radius: size;
        }

        Rectangle {
            width: size;
            height: size;
            background: color;
            border-radius: size;
        }
    }
}

export component Renderable inherits HorizontalLayout {
    padding-left: 5px;
    padding-right: 5px;

    in property <duration> hover-wait: 200ms;
    in property <bool> selected;
    in property <bool> addable;
    in property <bool> removable;
    in property <bool> editable;
    in property <bool> enabled: true;
    in property <brush> background: Palette.alternate-background;
    in property <brush> border-color: enabled ? background.brighter(0.5) : background.darker(0.8);
    in property <length> border-width;
    in property <length> border-radius: 8px;

    in property <bool> draggable: false;
    in property <int> position-shift: 0; // -1 = OneUp, 0 = None, 1 = OneDown

    in property <int> item-index: -1;
    in property <int> focused-index: -1;
    out property <bool> has-focus: root.item-index >= 0 && root.item-index == root.focused-index;

    out property <bool> hover: false;

    property <length> content-box-y: 0px;
    property <length> press_start_mouse_y: 0px;
    property <length> press_start_content_y: 0px;
    property <bool> dragging: false;

    property <length> handle-cursor-offset;
    property <bool> handle-pressed;

    callback skipping(int);
    callback moved-element-n-lines(int);

    callback preview();
    callback hover-preview();
    callback send-to-view();
    callback add-click();
    callback edit-click();
    callback remove-click();
    callback request-focus();

    hover-timer := Timer {
        interval: hover-wait;

        triggered => {
            hover-preview();
            self.stop();
        }
    }

    property <length> not-actively-dragged-position: {
        if (position-shift == 1) {
            return -i-content.height;
        } else if (position-shift == -1) {
            return i-content.height;
        } else {
            return 0px;
        }
    };
    animate not-actively-dragged-position { duration: 200ms; }

    property <length> cursor-correction: -0.5 * i-content.height;

    i-content := Rectangle {
        opacity: enabled ? 1.0 : 0.5;
        y: dragging ? content-box-y : not_actively_dragged_position;
        background: background.brighter((hover || selected || has-focus) ? 0.2 : 0.0);
        border-width: has-focus ? 2px : (border-width > 0px ? border-width : 0px);
        border-color: has-focus ? Palette.accent-background : border-color;
        border-radius: border-radius;
        animate background, border-width, border-color {
            duration: 150ms;
            easing: ease-in-out;
        }

        TouchArea {
            enabled: root.enabled;
            clicked => {
                root.request-focus();
                preview();
            }
            double-clicked => send-to-view();

            changed has-hover => {
                hover = self.has-hover;
                if self.has-hover {
                    hover-timer.start();
                } else {
                    hover-timer.stop();
                }
            }
            HorizontalLayout {
                width: 100%;
                spacing: 0px;

                if draggable: Rectangle {
                    width: 30px;
                    background: transparent;

                    VerticalLayout {
                        alignment: center;
                        HorizontalLayout {
                            alignment: end;
                            DragableIcon {
                                size: 5px;
                                color: (hover || handle-pressed) ? Palette.foreground : Palette.foreground.with-alpha(40%);
                            }
                        }
                    }

                    handle_touch := TouchArea {
                        mouse-cursor: MouseCursor.move;

                        property <int> count_skipped_lines: 0;
                        property <length> local_mouse_y <=> self.mouse-y;
                        property <bool> local_pressed <=> self.pressed;

                        changed local_pressed => {
                            handle_pressed = self.local_pressed;
                            if self.local_pressed {
                                dragging = true;
                                press_start_mouse_y = local_mouse_y;
                                press_start_content_y = content-box-y;
                            } else {
                                dragging = false;
                                let delta = content-box-y - not_actively_dragged_position;
                                let lines = round(delta / i-content.height);
                                moved-element-n-lines(lines);
                            }
                        }

                        changed local_mouse_y => {
                            if !self.local_pressed {
                                return;
                            }
                            let delta = self.local_mouse_y - press_start_mouse_y;
                            content-box-y = press_start_content_y + delta;
                            count_skipped_lines = round((content-box-y - not_actively_dragged_position + cursor_correction) / i-content.height);
                            skipping(count_skipped_lines);
                        }
                    }
                }

                VerticalLayout {
                    padding: 10px;

                    @children
                }
            }

            if (enabled && (hover || has-focus)): HorizontalLayout {
                y: 0px;
                x: parent.width - self.width;
                alignment: end;
                spacing: 5px;

                if editable: VerticalLayout {
                    alignment: start;

                    Rectangle {
                        border-radius: 8px;
                        background: Colors.gainsboro.brighter(i-edit-hover.has-hover ? 0.2 : 0.0);
                        VerticalLayout {
                            padding: 5px;

                            Image {
                                width: 16px;
                                height: 16px;
                                source: @image-url("../../icons/edit.svg");
                            }
                        }

                        i-edit-hover := TouchArea {
                            clicked => edit-click();
                        }
                    }
                }

                if addable: VerticalLayout {
                    alignment: start;

                    Rectangle {
                        border-radius: 8px;
                        background: Colors.royalblue.brighter(i-add-hover.has-hover ? 0.2 : 0.0);
                        VerticalLayout {
                            padding: 5px;

                            Image {
                                width: 16px;
                                height: 16px;
                                colorize: white;
                                source: @image-url("../../icons/plus.svg");
                            }
                        }

                        i-add-hover := TouchArea {
                            clicked => add-click();
                        }
                    }
                }

                if removable: VerticalLayout {
                    alignment: start;

                    VerticalLayout {
                        Rectangle {
                            border-radius: 8px;
                            background: Colors.indianred.brighter(i-rm-hover.has-hover ? 0.2 : 0.0);

                            VerticalLayout {
                                padding: 5px;

                                Image {
                                    width: 16px;
                                    height: 16px;
                                    colorize: white;
                                    source: @image-url("../../icons/remove.svg");
                                }
                            }

                            i-rm-hover := TouchArea {
                                clicked => remove-click();
                            }
                        }
                    }
                }
            }
        }
    }
}

export component RenderableList inherits Rectangle {
    in property <int> item-count: 0;
    in-out property <int> current-focused: i-focus-scope.has-focus ? i-focus-scope.focused-item : -1;

    callback item-focused(/* index */ int);
    callback request-move-by(int, int);

    in property <bool> draggable: false;

    in-out property <[int]> range-to-move-down: [-1, -1];
    in-out property <[int]> range-to-move-up: [-1, -1];

    forward-focus: i-focus-scope;

    changed current-focused => {
        i-focus-scope.focused-item = current-focused;
    }

    public function handleSkipping(index: int, offset: int) {
        if offset == 0 {
            range-to-move-down = [-1, -1];
            range-to-move-up = [-1, -1];
        } else if offset < 0 {
            range-to-move-down = [-1, -1];
            range-to-move-up = [index + offset, index];
        } else {
            range-to-move-down = [index + 1, index + 1 + offset];
            range-to-move-up = [-1, -1];
        }
    }

    public function handleMoved(index: int, offset: int) {
        if offset == 0 {
            range-to-move-down = [-1, -1];
            range-to-move-up = [-1, -1];
            return;
        }
        request-move-by(index, offset);
        range-to-move-down = [-1, -1];
        range-to-move-up = [-1, -1];
    }

    public pure function positionShiftForIndex(i: int) -> int {
        if (i >= range-to-move-down[0] && i < range-to-move-down[1]) {
            return 1; // OneDown
        } else if (i >= range-to-move-up[0] && i < range-to-move-up[1]) {
            return -1; // OneUp
        } else {
            return 0; // None
        }
    }

    i-focus-scope := FocusScope {
        property <int> focused-item: 0;
        width: 100%;
        height: 100%;
        key-pressed(event) => {
            if event.text == Key.UpArrow {
                self.focused-item = max(self.focused-item - 1, 0);
                current-focused = self.focused-item;
                root.item-focused(self.focused-item);
                return accept;
            }
            if event.text == Key.DownArrow {
                self.focused-item = min(self.focused-item + 1, root.item-count - 1);
                current-focused = self.focused-item;
                root.item-focused(self.focused-item);
                return accept;
            }
            return reject;
        }

        ScrollView {
            width: 100%;
            height: 100%;
            @children
        }
    }
}
